//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vhudson-jaxb-ri-2.1-833 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2012.02.19 at 04:43:47 PM CET 
//


package org.openworm.simulationengine.model.sph.x;

import org.openworm.simulationengine.model.sph.Vector3D;


public class Vector3DX extends Vector3D{

   
    public Vector3DX(Float x, Float y, Float z) {
		super();
		this.x = x;
		this.y = y;
		this.z = z;
	}
    
	public Vector3DX() {
		super();
	}

	public Vector3DX(Vector3D p)
	{
		this(p.getX(), p.getY(), p.getZ());
		setP(p.getP());
	}

	/** Summation of two vectors 
	 * @param v1
	 * @param v2
	 * @return vector 
	 */
	public static Vector3DX addition(Vector3DX v1, Vector3DX v2){
		return new Vector3DX(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
	}
	
	
	/**Subtraction of two vectors
	 * @param v1
	 * @param v2
	 * @return Vector3D
	 */
	public static Vector3DX subtraction(Vector3DX v1, Vector3DX v2){
		return new Vector3DX(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
	}
	/** Multiplicate vector on scalar
	 * @param v
	 * @param scalar
	 * @return
	 */
	public static Vector3DX mutiplicationOnScalar(Vector3DX v, float scalar){
		return new Vector3DX(v.x * scalar, v.y * scalar, v.z * scalar);
	}
	
	/** Copy coordinates of one vector to current
	 * @param v
	 */
	public void copy(Vector3DX v){
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
	}
	
	/**Get length of vector
	 * @return 
	 */
	public float length(){
		return (float)Math.sqrt(x*x + y*y + z*z);
	}
	/**
	 * Normalizes this Vector3D that its direction remains the same but its length is 1.
	 */
	public void unitize(){
		float len = this.length();
		if (len == 0)
			return;
		x /=len;
		y /= len;
		z /= len;
	}
	/** Scalar multiplication of two vectors
	 * @param v
	 * @return double value
	 */
	public double scalarMultiplication(Vector3DX v){
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}

}
